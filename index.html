<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris — Tiny Arcade</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121826; --text:#e6edf3; --muted:#94a3b8; --grid:#1f2937;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; background: radial-gradient(1200px 800px at 50% -10%, #0f172a, var(--bg)); color:var(--text); display:grid; place-items:center}
    .wrap{width:min(96vw,1000px)}
    header{display:flex; justify-content:space-between; align-items:center; margin-bottom:.75rem}
    .title{font-weight:800}
    .badge{font-size:.8rem; color:var(--muted)}
    .panel{background:linear-gradient(180deg,#0f172a,var(--panel)); border:1px solid #1f2937; border-radius:16px; padding:.75rem; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .grid{display:grid; grid-template-columns: 1fr 320px; gap:1rem}
    @media (max-width: 860px){ .grid{grid-template-columns: 1fr} }

    .stage-wrap{position:relative}
    canvas{background:#0a0f1a; border:1px solid var(--grid); border-radius:16px; width:100%; height:auto; image-rendering: pixelated}
    .hud{display:flex; gap:.5rem; flex-wrap:wrap; margin-bottom:.5rem}
    .stat{background:#0b1220; border:1px solid #1f2937; border-radius:12px; padding:.4rem .6rem;}
    .hold-next{display:grid; grid-template-columns:1fr 1fr; gap:.75rem}
    .box{background:#0b1220; border:1px solid #1f2937; border-radius:12px; padding:.5rem}
    .box h3{margin:.1rem 0 .4rem; font-size:.9rem; color:var(--muted)}
    .controls{display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.5rem}
    button, select{background:#0b1220; color:var(--text); border:1px solid #1f2937; border-radius:12px; padding:.45rem .7rem; font-weight:600}
    button.primary{background:linear-gradient(180deg,#06b6d4,#0891b2); color:#041316; border-color:#0ea5b7}

    .overlay{position:absolute; inset:0; display:grid; place-items:center; background:rgba(9,12,20,.6); border-radius:16px; backdrop-filter: blur(2px); opacity:0; pointer-events:none; transition:opacity .2s}
    .overlay.show{opacity:1; pointer-events:auto}
    .card{background:#0b1220; border:1px solid #1f2937; border-radius:16px; padding:1rem; width:min(92%,420px); text-align:center}
    .row{display:flex; gap:.5rem; justify-content:center; flex-wrap:wrap}
    .kbd{background:#0a1424; border:1px solid #1f2937; border-radius:8px; padding:.2rem .4rem; font-size:.85rem; color:var(--muted)}
    .mobile{display:none; color:var(--muted); font-size:.85rem}
    @media (max-width:640px){ .mobile{display:block} }

    .touch{display:none; gap:.5rem; justify-content:center; margin-top:.5rem}
    .touch button{min-width:64px}
    @media (max-width:860px){ .touch{display:flex} }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="badge">Tiny Arcade</div>
        <div class="title">Tetris</div>
      </div>
      <div class="badge">← → move • ↑ rotate • Z/X rotate • Space hard drop • C hold</div>
    </header>

    <div class="panel">
      <div class="grid">
        <div class="stage-wrap">
          <div class="hud">
            <div class="stat">Score: <b id="score">0</b></div>
            <div class="stat">Lines: <b id="lines">0</b></div>
            <div class="stat">Level: <b id="level">1</b></div>
            <div class="stat">Best: <b id="best">0</b></div>
          </div>
          <canvas id="stage" width="300" height="600" aria-label="Tetris playfield" role="img"></canvas>
          <div id="overlay" class="overlay show">
            <div class="card">
              <h2 id="ov-title">Ready?</h2>
              <p id="ov-msg">Clear lines by completing rows. Controls: <span class="kbd">←</span><span class="kbd">→</span> move, <span class="kbd">↑</span>/<span class="kbd">Z</span>/<span class="kbd">X</span> rotate, <span class="kbd">↓</span> soft drop, <span class="kbd">Space</span> hard drop, <span class="kbd">C</span> hold.</p>
              <div class="row" style="margin-top:.5rem">
                <button id="start" class="primary">Start</button>
                <button id="how">How to Play</button>
              </div>
              <p class="mobile" style="margin-top:.75rem">Tip: turn your phone sideways for a taller board.</p>
            </div>
          </div>
          <div class="touch">
            <button id="btn-left">←</button>
            <button id="btn-rotl">⟲</button>
            <button id="btn-drop">⤓</button>
            <button id="btn-rotr">⟳</button>
            <button id="btn-right">→</button>
          </div>
          <div class="controls">
            <button id="play" class="primary">Play</button>
            <button id="pause">Pause</button>
            <button id="reset">Reset</button>
            <label class="badge" for="grav">Gravity</label>
            <select id="grav">
              <option value="900">Chill</option>
              <option value="650" selected>Classic</option>
              <option value="480">Faster</option>
              <option value="340">Insane</option>
            </select>
          </div>
        </div>
        <div>
          <div class="hold-next">
            <div class="box">
              <h3>Hold (C)</h3>
              <canvas id="hold" width="120" height="120"></canvas>
            </div>
            <div class="box">
              <h3>Next</h3>
              <canvas id="next" width="120" height="240"></canvas>
            </div>
          </div>
          <div class="box" style="margin-top:.75rem">
            <h3>Scoring</h3>
            <div class="badge">Single 100 • Double 300 • Triple 500 • Tetris 800<br/>Soft drop +1/cell • Hard drop +2/cell</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Constants ----------
  const COLS = 10, ROWS = 20, CELL = 30; // stage 300x600
  const TILES = {
    I: { c:'#38bdf8', s:[[0,0,0,0, 1,1,1,1, 0,0,0,0, 0,0,0,0],[0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0]] },
    O: { c:'#facc15', s:[[0,1,1,0, 0,1,1,0, 0,0,0,0, 0,0,0,0]] },
    T: { c:'#a78bfa', s:[[0,1,0,0, 1,1,1,0, 0,0,0,0, 0,0,0,0],[0,1,0,0, 0,1,1,0, 0,1,0,0, 0,0,0,0],[0,0,0,0, 1,1,1,0, 0,1,0,0, 0,0,0,0],[0,1,0,0, 1,1,0,0, 0,1,0,0, 0,0,0,0]] },
    S: { c:'#34d399', s:[[0,1,1,0, 1,1,0,0, 0,0,0,0, 0,0,0,0],[0,1,0,0, 0,1,1,0, 0,0,1,0, 0,0,0,0]] },
    Z: { c:'#f87171', s:[[1,1,0,0, 0,1,1,0, 0,0,0,0, 0,0,0,0],[0,0,1,0, 0,1,1,0, 0,1,0,0, 0,0,0,0]] },
    J: { c:'#60a5fa', s:[[1,0,0,0, 1,1,1,0, 0,0,0,0, 0,0,0,0],[0,1,1,0, 0,1,0,0, 0,1,0,0, 0,0,0,0],[0,0,0,0, 1,1,1,0, 0,0,1,0, 0,0,0,0],[0,1,0,0, 0,1,0,0, 1,1,0,0, 0,0,0,0]] },
    L: { c:'#fb923c', s:[[0,0,1,0, 1,1,1,0, 0,0,0,0, 0,0,0,0],[0,1,0,0, 0,1,0,0, 0,1,1,0, 0,0,0,0],[0,0,0,0, 1,1,1,0, 1,0,0,0, 0,0,0,0],[1,1,0,0, 0,1,0,0, 0,1,0,0, 0,0,0,0]] },
  };
  const ORDER = ['I','O','T','S','Z','J','L'];

  // Super Rotation System kicks (simplified)
  const KICKS = {
    normal: {
      '0>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
      '1>0': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
      '1>2': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
      '2>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
      '2>3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
      '3>2': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
      '3>0': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
      '0>3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
    },
    I: {
      '0>1': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
      '1>0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
      '1>2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
      '2>1': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
      '2>3': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
      '3>2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
      '3>0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
      '0>3': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
    }
  };

  // ---------- Helpers ----------
  const $ = sel => document.querySelector(sel);
  const stage = $('#stage');
  const ctx = stage.getContext('2d');
  const nextCanvas = $('#next');
  const nextCtx = nextCanvas.getContext('2d');
  const holdCanvas = $('#hold');
  const holdCtx = holdCanvas.getContext('2d');

  const scoreEl = $('#score'), linesEl = $('#lines'), levelEl = $('#level'), bestEl = $('#best');
  const overlay = $('#overlay'), ovTitle = $('#ov-title'), ovMsg = $('#ov-msg');

  // localStorage high score
  const store = {
    get best(){ return +localStorage.getItem('tetris.best') || 0; },
    set best(v){ localStorage.setItem('tetris.best', String(v)); }
  }; bestEl.textContent = store.best;

  const emptyRow = () => Array(COLS).fill(null);
  function newField(){ return Array(ROWS).fill(0).map(emptyRow); }

  function bag(){
    const b = ORDER.slice();
    for (let i=b.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [b[i],b[j]]=[b[j],b[i]]; }
    return b;
  }

  // Piece structure
  function makePiece(type){
    const def = TILES[type];
    const states = def.s.map(s => { // normalize to arrays of [x,y]
      const cells=[]; for (let i=0;i<16;i++){ if (s[i]) cells.push([i%4, (i/4|0)]); }
      return cells;
    });
    return { type, c: def.c, r:0, x:3, y:-2, states };
  }

  function clone(o){ return JSON.parse(JSON.stringify(o)); }

  function cellsOf(p){ return p.states[p.r].map(([dx,dy])=>[p.x+dx, p.y+dy]); }

  function valid(field, piece){
    return cellsOf(piece).every(([x,y])=> y<ROWS && x>=0 && x<COLS && (y<0 || !field[y][x]));
  }

  function rotate(field, p, dir){
    const np = clone(p); np.r = (np.r + (dir>0?1:3)) % p.states.length;
    const sys = (p.type==='I')?KICKS.I:KICKS.normal;
    const key = `${p.r}>${np.r}`;
    const tests = sys[key] || [[0,0]];
    for (const [kx,ky] of tests){ const test = clone(np); test.x += kx; test.y += ky; if (valid(field,test)) return test; }
    return p; // no rotation if all kicks fail
  }

  function hardDropY(field, p){
    let test = clone(p); while(valid(field, {...test, y:test.y+1})) test.y++; return test.y;
  }

  function merge(field, p){ cellsOf(p).forEach(([x,y])=>{ if (y>=0) field[y][x] = { c:p.c }; }); }

  function clearLines(field){
    let cleared = 0;
    for (let y=ROWS-1;y>=0;y--){
      if (field[y].every(c=>c)){ field.splice(y,1); field.unshift(emptyRow()); cleared++; y++; }
    }
    return cleared;
  }

  // ---------- Game State ----------
  let field = newField();
  let queue = bag();
  let cur = makePiece(queue.shift());
  let hold = null; let canHold = true;
  let score = 0, lines = 0, level = 1;
  let gravity = +$('#grav').value; // ms per step
  let timer = null; let running = false; let paused = false;

  // ---------- Rendering ----------
  function drawCell(g, x,y, size, color){
    const px = x*size, py = y*size;
    g.fillStyle = color; g.fillRect(px+1, py+1, size-2, size-2);
    g.strokeStyle = 'rgba(255,255,255,.08)'; g.strokeRect(px+.5, py+.5, size-1, size-1);
  }

  function draw(){
    // board background
    ctx.clearRect(0,0,stage.width, stage.height);
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,stage.width, stage.height);
    ctx.strokeStyle = '#0f1a2f'; ctx.lineWidth = 1;
    // grid lines
    ctx.beginPath();
    for (let x=1;x<COLS;x++){ const p=x*CELL+.5; ctx.moveTo(p,0); ctx.lineTo(p,stage.height); }
    for (let y=1;y<ROWS;y++){ const p=y*CELL+.5; ctx.moveTo(0,p); ctx.lineTo(stage.width,p); }
    ctx.stroke();

    // placed tiles
    for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++){ const t=field[y][x]; if (t) drawCell(ctx,x,y,CELL,t.c); }

    // ghost
    const gy = hardDropY(field, cur);
    cellsOf({...cur, y:gy}).forEach(([x,y])=>{ if (y>=0){ ctx.globalAlpha=.25; drawCell(ctx,x,y,CELL,cur.c); ctx.globalAlpha=1; }});

    // current piece
    cellsOf(cur).forEach(([x,y])=>{ if (y>=0) drawCell(ctx,x,y,CELL,cur.c); });

    // next queue
    nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    let ny = 0; queue.slice(0,4).forEach(t=>{ drawMini(nextCtx, makePiece(t), 0, ny); ny += 56; });

    // hold
    holdCtx.clearRect(0,0,holdCanvas.width, holdCanvas.height);
    if (hold) drawMini(holdCtx, makePiece(hold), 0, 28);

    scoreEl.textContent = score; linesEl.textContent = lines; levelEl.textContent = level;
  }

  function drawMini(g, p, ox, oy){
    // center a 4x4 box in 120x120 (or 120x240 cell for next)
    const size = 24; const offx = Math.floor((120 - 4*size)/2) + ox; const offy = oy + Math.floor((120 - 4*size)/2);
    p.x = 0; p.y = 0; p.r = 0; // use spawn state
    p.states[0].forEach(([x,y])=>{ const px = offx + x*size; const py = offy + y*size; g.fillStyle = p.c; g.fillRect(px+1, py+1, size-2, size-2); g.strokeStyle='rgba(255,255,255,.08)'; g.strokeRect(px+.5, py+.5, size-1, size-1); });
  }

  // ---------- Gameplay ----------
  function refill(){ if (queue.length < 7) queue = queue.concat(bag()); }

  function spawn(){
    refill();
    cur = makePiece(queue.shift());
    cur.x = 3; cur.y = -2; cur.r = 0; canHold = true;
    if (!valid(field, cur)) { gameOver(); }
  }

  function step(){
    if (!running || paused) return;
    const moved = {...cur, y:cur.y+1};
    if (valid(field, moved)) { cur = moved; draw(); schedule(); return; }
    // lock
    merge(field, cur);
    const cleared = clearLines(field);
    if (cleared){
      const pts = [0,100,300,500,800][cleared];
      score += pts * level; lines += cleared; level = 1 + Math.floor(lines/10);
    }
    spawn();
    draw();
    schedule();
  }

  function schedule(){ clearTimeout(timer); const speed = Math.max(100, gravity - (level-1)*35); timer = setTimeout(step, speed); }

  function softDrop(){ const test = {...cur, y:cur.y+1}; if (valid(field,test)){ cur = test; score += 1; draw(); } }

  function hardDrop(){ const y = hardDropY(field, cur); const dist = y - cur.y; if (dist>0) score += dist*2; cur.y = y; draw(); step(); }

  function move(dx){ const test = {...cur, x:cur.x+dx}; if (valid(field,test)){ cur = test; draw(); } }

  function rotateCW(){ cur = rotate(field, cur, +1); draw(); }
  function rotateCCW(){ cur = rotate(field, cur, -1); draw(); }

  function doHold(){
    if (!canHold) return;
    if (hold==null){ hold = cur.type; spawn(); }
    else { const tmp = hold; hold = cur.type; cur = makePiece(tmp); cur.x=3; cur.y=-2; cur.r=0; if (!valid(field,cur)) { gameOver(); return; } }
    canHold = false; draw();
  }

  function reset(){ running=false; paused=false; clearTimeout(timer);
    field = newField(); queue = bag(); cur = makePiece(queue.shift()); hold=null; canHold=true; score=0; lines=0; level=1; draw();
    overlay.classList.add('show'); ovTitle.textContent='Ready?'; ovMsg.innerHTML='Clear lines by completing rows.'; }

  function play(){ if (!running){ running = true; paused=false; overlay.classList.remove('show'); schedule(); } }
  function pause(){ if (!running) return; paused = !paused; if (paused){ overlay.classList.add('show'); ovTitle.textContent='Paused'; ovMsg.textContent='Press Play/Resume to continue.'; clearTimeout(timer);} else { overlay.classList.remove('show'); schedule(); } }

  function gameOver(){ running=false; clearTimeout(timer); overlay.classList.add('show'); ovTitle.textContent='Game Over'; ovMsg.innerHTML=`Score: <b>${score}</b> • Lines: <b>${lines}</b>`; if (score>store.best){ store.best=score; } bestEl.textContent = store.best; }

  // ---------- Controls ----------
  const key = {
    ArrowLeft: ()=>move(-1), ArrowRight: ()=>move(1), ArrowDown: ()=>softDrop(),
    ArrowUp: ()=>rotateCW(), z: ()=>rotateCCW(), Z: ()=>rotateCCW(), x: ()=>rotateCW(), X: ()=>rotateCW(),
    ' ': ()=>hardDrop(), c: ()=>doHold(), C: ()=>doHold(), p: ()=>pause(), P: ()=>pause()
  };
  window.addEventListener('keydown', e=>{ if (key[e.key]){ e.preventDefault(); key[e.key](); } });

  // Buttons
  $('#play').addEventListener('click', play);
  $('#pause').addEventListener('click', pause);
  $('#reset').addEventListener('click', reset);
  $('#start').addEventListener('click', ()=>{ overlay.classList.remove('show'); play(); });
  $('#how').addEventListener('click', ()=>{ ovTitle.textContent='How to Play'; ovMsg.innerHTML='Move with ← →, rotate with ↑/Z/X, soft drop with ↓, hard drop with Space, hold with C. Clear 4 lines at once for a Tetris!'; });
  $('#grav').addEventListener('change', e=>{ gravity = +e.target.value; if (running && !paused) schedule(); });

  // Touch helpers
  function bind(id, fn){ const b=$(id); b.addEventListener('click', fn); }
  bind('#btn-left', ()=>move(-1));
  bind('#btn-right', ()=>move(1));
  bind('#btn-rotl', ()=>rotateCCW());
  bind('#btn-rotr', ()=>rotateCW());
  bind('#btn-drop', ()=>hardDrop());

  // Initial draw
  draw();
})();
</script>
</body>
</html>

      
  


  
